<h1 id="attributes">Attributes</h1>
<h3 id="overview" permalink="overview">Overview</h3>
<p>Model attributes are basic pieces of information about a model. A model called <code>Person</code> might have attributes called <code>firstName</code>, <code>lastName</code>, <code>phoneNumber</code>, <code>age</code>, <code>birthDate</code> and <code>emailAddress</code>.
<!---
TODO: address sql vs. no sql and stuff like:
"""
In most cases, this data is _homogenous_, meaning each record has the same attributes,
"""
--></p>
<h3 id="attribute-options" permalink="attribute-options">Attribute Options</h3>
<p>These options can be used to enforce various constraints and add special enhancements to our model attributes.</p>
<h6 id="type">type</h6>
<p>Specifies the type of data that will be stored in this attribute.  One of:</p>
<ul>
<li>string</li>
<li>text</li>
<li>integer</li>
<li>float</li>
<li>date</li>
<li>datetime</li>
<li>boolean</li>
<li>binary</li>
<li>array</li>
<li>json</li>
<li>mediumtext</li>
<li>longtext</li>
<li>objectid</li>
</ul>
<h6 id="defaultsto">defaultsTo</h6>
<p>When a record is created, if no value was supplied, the record will be created with the specified <code>defaultsTo</code> value. The supplied value can also be a function that waterline will run while creating the record.</p>
<pre><code class="javascript">attributes: {
  phoneNumber: {
    type: &apos;string&apos;,
    defaultsTo: &apos;111-222-3333&apos;
  },
  orderNumber: {
    type: &apos;text&apos;,
    defaultsTo: function() {
      return uuid.v4();
    }
  }
}
</code></pre><!-- __LANG=%%__ -->
<h6 id="autoincrement">autoIncrement</h6>
<p>Sets up the attribute as an auto-increment key.  When a new record is added to the model, if a value for this attribute is not specified, it will be generated by incrementing the most recent record&apos;s value by one. Note: Attributes which specify <code>autoIncrement</code> should always be of <code>type: &apos;integer&apos;</code>. Also, bear in mind that the level of support varies across different datastores. For instance, MySQL will not allow more than one auto-incrementing column per table.</p>
<pre><code class="javascript">attributes: {
  placeInLine: {
    type: &apos;integer&apos;,
    autoIncrement: true
  }
}
</code></pre><!-- __LANG=%%__ -->
<h6 id="unique">unique</h6>
<p>Ensures no two records will be allowed with the same value for the target attribute. This is an adapter-level constraint, so in most cases this will result in a unique index on the attribute being created in the underlying datastore.</p>
<pre><code class="javascript">attributes: {
  username: {
    type: &apos;string&apos;,
    unique: true
  }
}
</code></pre><!-- __LANG=%%__ -->
<blockquote>
<p>When using MySQL with the <code>utf8mb4</code> character set, you will need to add the <code>size</code> constraint to the appropriate column in your table directly via MySQL. Otherwise, since <code>type: &apos;string&apos;</code> is translated to <code>varchar(255)</code> in the MySQL adapter, the <code>unique: true</code> constraint will cause an &apos;index too long&apos; error: <code>ER_INDEX_COLUMN_TOO_LONG: Index column size too large. The maximum column size is 767 bytes.</code></p>
</blockquote>
<!--

Omitting `index` from docs for now.

###### index

Will create a simple index in the underlying datastore for faster queries if available. This is only for simple indexes and currently dosn't support compound indexes. For these you will need to create them yourself or use a migration.

There is currently an issue with adding indexes to string fields. Because Waterline performs its queries in a case insensitive manner we are unable to use the index on a string attribute. There are some workarounds being discussed but nothing is implemented so far. This will be updated in the near future to fully support indexes on strings.

javascript
attributes: {
  email: {
    type: 'string',
    index: true
  }
}

-->
<h6 id="primarykey">primaryKey</h6>
<p>Use this attribute as the the primary key for the record. Only one attribute per model can be the <code>primaryKey</code>.  Note: This should never be used unless <a href="/documentation/concepts/ORM/model-settings.html?q=autopk">autoPK</a> is set to false.</p>
<pre><code class="javascript">attributes: {
  uuid: {
    type: &apos;string&apos;,
    primaryKey: true,
    required: true
  }
}
</code></pre><!-- __LANG=%%__ -->
<h6 id="enum">enum</h6>
<p>A special validation property which only saves data which matches a whitelisted set of values.</p>
<pre><code class="javascript">attributes: {
  state: {
    type: &apos;string&apos;,
    enum: [&apos;pending&apos;, &apos;approved&apos;, &apos;denied&apos;]
  }
}
</code></pre><!-- __LANG=%%__ -->
<!--
These are not ready for prime-time yet, but listing them here so they're easy to reference and add to official docs later:

###### example

An example value for this attribute, e.g. "Albus Dumbledore".


###### validationMessage

A custom validation message to use when any validations fail for this attribute.

-->
<h6 id="size">size</h6>
<p>If supported in the adapter, can be used to define the size of the attribute. For example in MySQL, <code>size</code> can be specified as a number (<code>n</code>) to create a column with the SQL data type: <code>varchar(n)</code>.</p>
<pre><code class="javascript">attributes: {
  name: {
    type: &apos;string&apos;,
    size: 24
  }
}
</code></pre><!-- __LANG=%%__ -->
<h6 id="columnname">columnName</h6>
<p>Inside an attribute definition, you can specify a <code>columnName</code> to force Sails/Waterline to store data for that attribute in a specific column in the configured connection (i.e. database).  Be aware that this is not necessarily SQL-specific-- it will also work for MongoDB fields, etc.</p>
<p>While the <code>columnName</code> property is primarily designed for working with existing/legacy databases, it can also be useful in situations where your database is being shared by other applications, or you don&apos;t have access permissions to change the schema.</p>
<p>To store/fetch your model&apos;s <code>numberOfWheels</code> attribute into/from the <code>number_of_round_rotating_things</code> column:</p>
<pre><code class="javascript">// An attribute in one of your models:
  // ...
  numberOfWheels: {
    type: &apos;integer&apos;,
    columnName: &apos;number_of_round_rotating_things&apos;
  }
  // ...
</code></pre><!-- __LANG=%%__ -->
<p>Now for a more thorough/realistic example.</p>
<p>Let&apos;s say you have a <code>User</code> model in your Sails app that looks like this:</p>
<pre><code class="javascript">// api/models/User.js
module.exports = {
  connection: &apos;shinyNewMySQLDatabase&apos;,
  attributes: {
    name: {
      type: &apos;string&apos;
    },
    password: {
      type: &apos;string&apos;
    },
    email: {
      type: &apos;email&apos;,
      unique: true
    }
  }
};
</code></pre><!-- __LANG=%%__ -->
<p>Everything works great, but instead of using an existing MySQL database sitting on a server somewhere that happens to house your app&apos;s intended users:</p>
<pre><code class="javascript">// config/connections.js
module.exports = {
  // ...

  // Existing users are in here!
  rustyOldMySQLDatabase: {
    adapter: &apos;sails-mysql&apos;,
    user: &apos;bofh&apos;,
    host: &apos;db.eleven.sameness.foo&apos;,
    password: &apos;Gh19R!?had9gzQ#Q#Q#%AdsghaDABAMR&gt;##G&lt;ADMBOVRH@)$(HTOADG!GNADSGADSGNBI@(&apos;,
    database: &apos;jonas&apos;
  },
  // ...
};
</code></pre><!-- __LANG=%%__ -->
<p>Let&apos;s say there&apos;s a table called <code>our_users</code> in the old MySQL database that looks like this:</p>
<table>
<thead>
<tr>
<th>the_primary_key</th>
<th>email_address</th>
<th>full_name</th>
<th>seriously_encrypted_password</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>mike@sameness.foo</td>
<td>Mike McNeil</td>
<td>ranchdressing</td>
</tr>
<tr>
<td>14</td>
<td>nick@sameness.foo</td>
<td>Nick Crumrine</td>
<td>thousandisland</td>
</tr>
</tbody>
</table>
<p>In order to use this from Sails, you&apos;d change your <code>User</code> model to look like this:</p>
<pre><code class="javascript">// api/models/User.js
module.exports = {
  connection: &apos;rustyOldMySQLDatabase&apos;,
  tableName: &apos;our_users&apos;,
  attributes: {
    id: {
      type: &apos;integer&apos;,
      unique: true,
      primaryKey: true,
      columnName: &apos;the_primary_key&apos;
    },
    name: {
      type: &apos;string&apos;,
      columnName: &apos;full_name&apos;
    },
    password: {
      type: &apos;string&apos;,
      columnName: &apos;seriously_encrypted_password&apos;
    },
    email: {
      type: &apos;email&apos;,
      unique: true,
      columnName: &apos;email_address&apos;
    }
  }
};
</code></pre><!-- __LANG=%%__ -->
<blockquote>
<p>You might have noticed that we also used the <a href="/documentation/concepts/ORM/model-settings.html?q=tablename"><code>tableName</code></a> property in this example.  This allows us to control the name of the table that will be used to house our data.</p>
</blockquote>
<docmeta name="displayName" value="Attributes">
</docmeta>